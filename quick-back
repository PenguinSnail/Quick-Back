#!/bin/sh

# quick backup script
# by PenguinSnail and Bithakr
# ------------------------------

#Define variables
#Set destination path and destination device/directory
DEST_PATH=/mnt/quick-back
DEST=$DEST_PATH
#set source path
SRC=/
#Set boolean values for force override, exclude directory, and FS formatting
FORCE=0
FORMAT=0
BOOLEXCLUDE=0
#multiple rsync --excludes
EXCLUDESNUM=0
EXCLUDEDIR=()
#set the default rsync options
OPTIONS="-apx --no-i-r --info=progress2"

#Define functions

usage () 
{
#Display a help dialog for quick-back
echo "Usage: quick-back [OPTION]..."
echo "Create an incremental backup to an external drive or directory (using rsync)"
echo "Default Backup Directory: /mnt/quick-back"
echo "Default Source Directory: /"
echo ""
echo "	-h, --help | Dispay this help dialog"
echo "  -v, --verbose | Run in verbose mode - display all files being modified without the progress meter"
echo "	-e, --exclude | Exempt another folder from backup (/dev, /run, /sys, /proc, and more importantly /tmp already excluded)"
echo "	-d, --destination | Use an alternate backup destination (accepts /dev/XXX or a path)"
echo "	-s, --source | Use an alternate source destination"
echo "	--force-ignore | Force backup if destination isn't a mountpoint and ignore destination filesystem type"
}


backup ()
{
#backup $SRC to $DEST_PATH
echo "Starting backup (this will take a few minutes)..."
#if the exclude boolean is false (0) then run rsync from source to destination excluding temporary filesystems and /boot
if [ "$BOOLEXCLUDE" = "0" ]; then
    rsync $OPTIONS --delete --exclude=/boot/ --exclude=/run/* --exclude=/proc/* --exclude=/tmp/* --exclude=/sys/* --exclude=/dev/* --exclude=$DEST_PATH $SRC/* $DEST_PATH
#If the exclude boolean is true (1) then run rsync from source to destination excluding temporary file systems, /boot, and the excluded path specified by command options
elif [ "$BOOLEXCLUDE" = "1" ]; then
    CMD="rsync $OPTIONS --delete --exclude=/boot/ --exclude=/run/* --exclude=/proc/* --exclude=/tmp/* --exclude=/sys/* --exclude=/dev/* --exclude=$DEST_PATH $SRC/* $DEST_PATH"
		while [ "$EXCLUDESNUM" -ge 1 ]; do #LIFO queue
			CMD="${CMD} --exclude="
    		CMD="${CMD}${EXCLUDEDIR[$EXCLUDESNUM]}"
			EXCLUDESNUM=$(expr $EXCLUDESNUM - 1)
		done
    eval "$CMD"
fi
}


backup_boot ()
{
#if /boot exists on the source then
if [ -d "$SRC"/boot ]; then
#run rsync to copy the initramfs and kernel to the backup
if ! rsync $OPTIONS --delete "$SRC"/boot/*vmlinuz* "$DEST_PATH"/boot/; then
	echo "failed to backup the kernel"
	echo "does it not exist?"
fi
if ! rsync $OPTIONS --delete "$SRC"/boot/*initramfs* "$DEST_PATH"/boot/; then
	echo "failed to backup the kernel"
	echo "does it not exist?"
fi
fi
}


check_force ()
{
#if the forced boolean is true (1) then
if [ "$FORCE" = "1" ]; then
#display a message warning of the fored implications such as fillign storage and non-bootable backups
	echo "You are forcing this program to ignore where it is backing up to."
	echo "If you are backing up to a non-mountpoint destination, you WILL fill up your storage."
	echo "If you are backing up to a mount with a different filesystem, it will not be bootable."
	printf "Do you wish to continue? [y/N] >"
#get confirmation to continue from user
	read -r CONFIRM	
#if user input doesnt equal y then exit, else directly skip to the backup function
	if [ "$CONFIRM" != "y" ]; then
		echo "Exiting program."
		exit 1
	fi
fi
}


check_source () {
#exit if source doesnt exist
if ! df -h "$SRC" > /dev/null; then
	echo "invalid source"
	echo "exiting..."
	exit 1
fi
}


backup_path () {
#Determine the path to be used for the backup
#If $DEST is a /dev/xxx device, $DEST_PATH=/mnt/quick-back
case "$DEST" in 
	/dev/* )
		DEST_PATH="/mnt/quick-back"
	;;
	* )
		#otherwise $DEST_PATH=$DEST
		DEST_PATH="$DEST"
	;;
esac
}


dest_mount () {
#if the force boolean is false then
if [ "$FORCE" = "0" ]; then
	#if the destination path equals destination passed by option
	if [ "$DEST_PATH" = "$DEST" ]; then
		#check if the destination path is not a mountpoint (Found searching /proc/mounts) then
		if ! grep -qs " $DEST_PATH " /proc/mounts; then
			#exit
			echo "destination path $DEST_PATH is not a mountpoint"
			echo "exiting..."
			exit 1
		fi
	fi
fi
}


trailing_slash () {
#if source isn't /, remove trailing slash (/) if it exists
if ! [ "$SRC" = "/" ]; then
	last_chr_src=$(echo "$SRC" | tail -c 2)
	if [ "$last_chr_src" = "/" ]; then
		SRC=${SRC%?}
	fi
fi


#remove trailing slash from destination if present
if ! [ "$DEST_PATH" = "/" ]; then
	last_chr_dest=$(echo "$DEST_PATH" | tail -c 2)
	if [ "$last_chr_dest" = "/" ]; then
		DEST_PATH=${DEST_PATH%?}
	fi
elif [ "$DEST_PATH" = "/" ]; then
	echo "you can't backup to root!"
	echo "exiting..."
	exit 1
fi
}


src_vars () {
#find top mount of source using df
SRC_MNT=$(df -h "$SRC" | tail -n +2 | awk '{ print $6 }')
#find FS and mount options of source
source_TYPE=$(findmnt -n -o FSTYPE "$SRC_MNT")
source_OPTS=$(findmnt -n -o OPTIONS "$SRC_MNT")
}


mount_dest () {
#if destination is a device (Does it exist in /dev) then 
case "$DEST" in
	/dev/* )
		echo "Destination device is $DEST"
		echo "Mounting $DEST on $DEST_PATH"
		#unmount the device
		umount "$DEST"
		#find out the filesystem of the device
		dest_TYPE="$(blkid /dev/sdb9 | grep -o 'TYPE=[^[:space:]]*' | grep -o '".*"' | sed 's/\"//g')"
		#if the source FS = dest FS then remount with source options
		if [ "$dest_TYPE" = "$source_TYPE" ]; then
			if ! mount "$DEST" -o "$source_OPTS" "$DEST_PATH"; then
				echo "mount failed"
				echo "exiting program..."
				exit 1
			fi
		else
		#else remount without options
			if ! mount "$DEST" "$DEST_PATH"; then
				echo "mount failed"
				echo "exiting program..."
				exit 1
			fi	
		fi
	;;
esac
}


dest_vars () {
#find FS and device of destination
dest_TYPE=$(findmnt -n -o FSTYPE "$DEST_PATH")
dest_DEV=$(findmnt -n -o SOURCE "$DEST_PATH")
}


filesystems_check ()
{
if [ "$FORCE" != "1" ]; then
	if [ "$source_TYPE" != "$dest_TYPE" ]; then
		echo "Your destination filesystem is not the same as your source filesystem."
		echo "This may cause issues with permissions and will cause the backup to not be bootable"
		echo "Reformat the destination to match the source?"
		echo "WARNING! This will erase ALL data on the destination! Procede with caution!"
		printf "[y/N] >"
		read -r CONFIRM_FS
		if [ "$CONFIRM_FS" != "y" ]; then
			#If user doesnt say yes to format, confirm they wish to continue with the wrong format
			echo "Continue to backup without proper drive format?"
			printf "[y/N] >"
			read -r FS_CONTINUE
			if [ "$FS_CONTINUE" != "y" ]; then
				#If confirmation doesnt equal y, exit
				exit 1
			fi
			return
		fi
		#If the confirmation to format equals y, set format boolean to true (1)
		FORMAT=1
	fi
fi
}

format ()
{
#if the destination is a device, the format boolean is true, and the destination is properly unmounted, format the destination to amtch the source using two different commands. One for btrfs and one for all other FS types
if grep -qs " $DEST_PATH " /proc/mounts; then
	if [ "$FORMAT" = "1" ]; then
		echo "Formating destination device..."
		if umount "$dest_DEV"; then
			if [ "$source_TYPE" = "btrfs" ]; then
				if ! mkfs."$source_TYPE" -f "$dest_DEV"; then
					echo "failed to format the destination"
					exit 1
				fi
			else
				if ! mkfs."$source_TYPE" -F "$dest_DEV"; then
					echo "failed to format the destination"
					exit 1
				fi
			fi
			#$DEST_PATH="/mnt/quick-back"
			#Run the function to remount the device
			if ! mount "$dest_DEV" -o "$source_OPTS" "$DEST_PATH"; then
				echo "mount failed"
				echo "exiting program..."
				exit 1
			fi
		else
			#If unmount fails, exit with error code
			echo "failed to unmount destination device"
			echo "exiting program..."
			exit 1
		fi
	fi
fi
}


subvolumes ()
{
if [ "$source_TYPE" = "btrfs" ] && [ "$(findmnt -n -o FSTYPE $DEST_PATH)" = "btrfs" ]; then
btrfs subvolume list -t "$SRC_MNT" | tail -n +3 | awk '{ print $4 }' > /tmp/quick-back-subvolumes
while read -r paths ; do
paths=/$paths
case $paths in
	$SRC* )
		echo "$paths is a subvolume in the top level mount"
		SUBVOL="${paths%$SRC}"
		echo "creating subvolume on $DEST_PATH$SUBVOL"
		mkdir -p "$DEST_PATH$SUBVOL" > /dev/null 2>&1
		rmdir "$DEST_PATH$SUBVOL" > /dev/null 2>&1
		btrfs subvolume create "$DEST_PATH$SUBVOL" > /dev/null 2>&1
	;;
esac
done < /tmp/quick-back-subvolumes
fi
}


#parse command options
while [ "$1" != "" ]; do
    case $1 in
        -d | --destination )    shift
                                DEST=$1
                                ;;
        -s | --source )         shift
                                SRC=$1
                                ;;
	--force-ignore )        	FORCE=1
                                ;;
	-e | --exclude )			BOOLEXCLUDE=1
								EXCLUDESNUM=$((EXCLUDESNUM+1))
								shift
								EXCLUDEDIR[$EXCLUDESNUM]=$1
								;;
        -h | --help )           usage
                                exit
                                ;;
	-v | --verbose )        	OPTIONS="-avpx"
                                ;;
        * )                     echo "invalid option "$1""
                                usage
                                exit 1
    esac
    shift
done

#require sudo
if [ "$(id -u)" != 0 ]; then
    echo "Please run with sudo:"
    echo "sudo $0 $*"
    exit 1
fi


#Call functions
check_source
check_force
backup_path
trailing_slash
dest_mount
src_vars
mount_dest
dest_vars
filesystems_check
format
subvolumes
backup
backup_boot
echo "Backup Complete!"
exit
